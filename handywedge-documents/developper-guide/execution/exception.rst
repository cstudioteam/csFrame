例外処理
=========
.. index::
   single: チェック例外
   single: 非チェック例外
   single: Runtime Exception
   pair: @FWBusinessException; アノテーション

原則として処理の途中で発生した例外（Exceptionクラスのサブクラス）はアプリケーションが責任を持って例外処理を行う。

致命的なエラー（Errorクラスのサブクラス）の場合は **HandyWedge** にエラー処理を委譲する。

-----------------
業務的な例外処理
-----------------
アプリケーションは業務的に独自に実装した例外をスローすることができる。

例えば、新規に登録しようとしたIDが既に登録されている場合、業務ロジックで例外をスローして画面側でエラー処理を行いたいような場合には、
**HandyWedge** で規定する **@FWBusinessExceptionアノテーション** を付けた業務例外クラスを実装してスローする。

.. code-block:: java
   :emphasize-lines: 1

   @FWBusinessException
   public class SampleAppException extends Exception {
   　     // ・・・
   }


ビジネスロジックの出口で **HandyWedge** が **@FWBusinessExceptionアノテーション** が付いていない例外をキャッチした場合、**HandyWedge** では
致命的なエラーとして処理する。

**HandyWedge** では致命的なエラーをキャッチした場合、エラーの内容およびスタックトレース情報をエラーログに出力する。

.. tip:: @FWBusinessExceptionアノテーションが指定されているクラスを継承したサブクラスでも@FWBusinessExceptionアノテーションは有効ではあるが、各クラスに明示的に指定することを推奨する。また、このような例外クラスをフレームワークでキャッチした場合、警告（WARN）レベルでログ出力する。

------------------------------
チェック例外と非チェック例外
------------------------------
基本的にはアプリケーションではスローされる例外は呼び出し元でチェックできるようチェック例外として実装する。

設計上ありえないケースなどを例外とする場合は、非チェック例外（Runtime Exception）でスローし、**HandyWedge** に致命的エラーと処理させる。
この場合、エラーの原因となったデータの情報などを例外クラスに持たせておくと障害解析がやりやすくなる。
